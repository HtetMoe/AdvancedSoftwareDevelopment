Scenario:
Imagine a basic Coffee class that can have additional features like milk, sugar, or whipped cream added to it using decorators.

Components of the Decorator Pattern:
1. Component: An interface or abstract class (Coffee) that defines the behavior.
2. Concrete Component: A class that implements the component interface (SimpleCoffee).
3. Decorator: An abstract class that implements the component interface and
   has a reference to a component object (CoffeeDecorator).
4. Concrete Decorators: Classes that extend the decorator class to add functionality
   (MilkDecorator, SugarDecorator).

Explanation:
=> Same Super-Type: Both SimpleCoffee and decorators (MilkDecorator, SugarDecorator)
   implement the Coffee interface, ensuring they are interchangeable.
=> Polymorphism: All decorators can be treated as Coffee objects,
   allowing them to be used wherever Coffee is expected.
=> Layering Behaviors: Decorators can be layered on top of each other
   (e.g., milk, then sugar), dynamically extending the functionality of the base object (SimpleCoffee).
